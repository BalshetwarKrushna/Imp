//2d-Transform

#include <GL/glut.h>
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int choice, edges;
vector<int> x, y;
int windowWidth = 800, windowHeight = 800;

double roundOff(double d) {
    return floor(d + 0.5);
}

void drawAxes() {
    glColor3f(0, 0, 0); // Black axes
    glBegin(GL_LINES);
        glVertex2i(-windowWidth, 0);
        glVertex2i(windowWidth, 0);
        glVertex2i(0, -windowHeight);
        glVertex2i(0, windowHeight);
    glEnd();
}

void drawPolygon(vector<int> x, vector<int> y, float r, float g, float b) {
    glColor3f(r, g, b);
    glBegin(GL_POLYGON);
    for (int i = 0; i < edges; ++i)
        glVertex2i(x[i], y[i]);
    glEnd();
}

void scalePolygon() {
    int sx, sy;
    cout << "Enter scaling factors sx and sy: ";
    cin >> sx >> sy;

    vector<int> xs = x, ys = y;
    for (int i = 0; i < edges; ++i) {
        xs[i] = x[i] * sx;
        ys[i] = y[i] * sy;
    }

    drawPolygon(xs, ys, 0, 0, 1); // Blue scaled polygon
}

void rotatePolygon() {
    int xr, yr;
    cout << "Enter the point (xr, yr) about which to rotate: ";
    cin >> xr >> yr;
    double angle;
    cout << "Enter angle of rotation (in degrees): ";
    cin >> angle;
    angle = angle * 3.14159 / 180;

    vector<int> xr_x = x, yr_y = y;
    for (int i = 0; i < edges; ++i) {
        int x_shifted = x[i] - xr;
        int y_shifted = y[i] - yr;
        xr_x[i] = roundOff(x_shifted * cos(angle) - y_shifted * sin(angle)) + xr;
        yr_y[i] = roundOff(x_shifted * sin(angle) + y_shifted * cos(angle)) + yr;
    }

    drawPolygon(xr_x, yr_y, 0, 1, 0); // Green rotated polygon
}

void reflectPolygon() {
    char axis;
    cout << "Enter reflection axis (X or Y): ";
    cin >> axis;

    vector<int> rx = x, ry = y;
    if (axis == 'X' || axis == 'x') {
        for (int i = 0; i < edges; ++i)
            ry[i] = -y[i];
    } else {
        for (int i = 0; i < edges; ++i)
            rx[i] = -x[i];
    }

    drawPolygon(rx, ry, 1, 0, 1); // Purple reflected polygon
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    drawAxes();
    drawPolygon(x, y, 1, 0, 0); // Red original polygon

    switch (choice) {
        case 1: scalePolygon(); break;
        case 2: rotatePolygon(); break;
        case 3: reflectPolygon(); break;
        default: cout << "Invalid choice"; break;
    }

    glFlush();
}

void init() {
    glClearColor(1, 1, 1, 1); // White background
    gluOrtho2D(-windowWidth, windowWidth, -windowHeight, windowHeight); // 2D space
}

int main(int argc, char** argv) {
    cout << "2D TRANSFORMATIONS:\n";
    cout << "1. Scaling\n2. Rotation about arbitrary point\n3. Reflection\nEnter your choice: ";
    cin >> choice;

    cout << "Enter number of edges: ";
    cin >> edges;

    cout << "Enter the coordinates (x y) of each vertex:\n";
    for (int i = 0; i < edges; ++i) {
        int xi, yi;
        cout << "Vertex " << i + 1 << ": ";
        cin >> xi >> yi;
        x.push_back(xi);
        y.push_back(yi);
    }

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(windowWidth, windowHeight);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("2D Transformations with Axes");
    init();
    glutDisplayFunc(display);
    glutMainLoop();

    return 0;
}

sample inputs :- 

1) SCALING :- 1
3
50 50
100 50
75 100
Enter scaling factors sx and sy: 2 1

2)ROTATION :- 
2
4
-50 50
50 50
50 -50
-50 -50
Enter the point (xr, yr): 0 0
Enter angle: 90

3) REFLECTION :-
3
3
50 50
100 50
75 100
Enter reflection axis: X

// g++ ya.cpp -lGL -lGLU -lglut
//./a.out

